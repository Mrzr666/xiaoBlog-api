#server
server:
  port: 8888
  servlet:
    context-path: /api

#upload
spring:
  profiles:
    active: zr
  http:
    multipart:
      maxFileSize: 20Mb
      maxRequestSize: 30Mb
  mvc:
    static-path-pattern: /**
#  resources:
#    static-locations: classpath:/META-INF/resources/,classpath:/resources/,\
#    classpath: /static/,classpath:/public/,file:${me.upload.path}

  datasource:
    url: jdbc:mysql://rm-uf6mmio3c34252299go.mysql.rds.aliyuncs.com/xbtest?serverTimezone=Asia/Shanghai
    username: xbtest
    password: Xbtest123456
#    url: jdbc:mysql://139.196.12.156:3306/xiaoBlog?serverTimezone=Asia/Shanghai
#    username: xsyroot
#    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.jdbc.Driver

  druid:
    initial-size: 5
    min-idle: 1
    max-active: 20
    query-timeout: 6000
    #设置removeAbandoned="true"时，当连接池连接数到达(getNumIdle() < 2) and (getNumActive() > getMaxActive() - 3)  [空闲的连接小于2并且活动的连接大于(最大连接-3)] 时便会启动连接回收，
    #那种活动时间超过removeAbandonedTimeout="1800"的连接将会被回收，
    #同时如果logAbandoned="true"设置为true,程序在回收连接的同时会打印日志。
    #removeAbandoned是连接池的高级功能，理论上这中配置不应该出现在实际的生产环境，因为有时应用程序执行长事务，可能这种情况下，会被连接池误回收，该种配置一般在程序测试阶段，为了定位连接泄漏的具体代码位置，被开启。
    #生产环境中连接的关闭应该靠程序自己保证。
    #先关着
    remove-abandoned: false
    #必须要remove-abandoned为false才能生效，这样连接出问题的时候，每隔3000秒请求
    async-init: true
    time-between-connect-error-millis: 3000

    #先关着
    log-abandoned: false
    transaction-query-timeout: 6000
    remove-abandoned-timeout: 1800
    filters: wall,stat
    connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=10000
    stat-view-servlet:
      login-username: bda
      login-password: bda
      url-pattern: /druid/*
      reset-enable: false
    web-stat-filter:
      url-pattern: /*
      exclusions: "*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*"
      #超时重试次数
    connection-error-retry-attempts: 3
    #必须为false（失败后会不断请求数据库，请求在TIME-WAIT，在数据库服务重启后，所有等待请求会访问数据库），
    #为true上面参数才会生效（：true表示pool向数据库上面的重试请求连接此时失败后标记整个pool为block并close，
    #就算后端数据库恢复正常也不进行重连，客户端对pool的请求都拒绝掉。false表示不会标记 pool为block，新的请求都会尝试去数据库请求connection。
    #默认为false。因此，如果想让数据库和网络故障恢复之后，pool能继续请求正常资源必须把此项配置设为false）
    break-after-acquire-failure: false
    #检查连接正常的sql
    validation-query: select 1 from xiaoblog
    #配置多久检测一次空闲连接（可以选择是否尽早关闭连接，看压力在server还是数据库端）
    time-between-eviction-runs-millis: 60000
    #数据库连接最小生存时间
    min-evictable-idle-time-millis: 300000

    #redis
    redis:
      # Redis数据库索引（默认为0）
      database: 0
      # Redis服务器地址
      host: r-uf6e1933ed7d3744pd.redis.rds.aliyuncs.com
      # Redis服务器连接端口
      port: 6379
      # Redis服务器连接密码（默认为空）
      password: r-uf6e1933ed7d3744:Xiao8738361
      timeout: 0
      pool:
        # 连接池最大连接数（使用负值表示没有限制）
        max-active: 8
        # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: -1
        # 连接池中的最大空闲连接
        max-idle: 8
        # 连接池中的最小空闲连接
        min-idle: 0
        # 连接超时时间（毫秒）
        timeout: 0


        mybatis-plus:
          mapper-locations: classpath:mapper/*.xml

# upload path
me:
  upload:
    path: D:/blogFile/

#cache
#spring.cache.ehcache.config=classpath:ehcache.xml



#log
logging:
  config:
    classpath: log4j2-spring.xml